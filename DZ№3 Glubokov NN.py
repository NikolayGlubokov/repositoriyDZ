from random import randint  # Задание произвольного массива

liner = '---------------'
print(liner * 8)
print('Задание №1')
n = []
for i in range(20):
    sls = randint(0, 100)
    n.append(sls)
print(n)
print("Сумма всех значений списка равна: ", sum(n))
print(liner * 8)
print('Задание №2')
a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]

print('Заданный список с вложенными списками: ', a)

for row in a:  # Данным способом я отображаю в виде таблицы изначальный массив
    for col in row:
        print(col, end='\t\t')
    print()
print()

b = []  # Данный массив мне нужен для составления нового массива. Я выбрал способ, в котором я разрушаю изначальный массив,
for i in a:  # чтобы потом собрать общий единый массив из значений начального массива, в том порядке, в каком они стоят. По сути,
    for j in i:  # я "как-бы" лишил внутренние массивы скобок.
        b.append(j)
# print(b)
c = []
e = []
d = 0
f = len(a[
            0])  # Так как я заметил, что в основном длинна внутренних массивов одинаковая, что подходит под базы данных, где количество обьектов в них может быть разным,
for i in range(
        f):  # а характеристики самих обьектов часто одинаковые, то я внутренний список с индексом 0, потому что не увидел разницу - какой именно брать элемент.
    while d < f:
        for j in range(d, len(b), len(a[0])):
            c.append(b[j])
        e.extend([c])
        c = []
        d += 1
# print(e)

for row in e:  # Данный массив сформирован ровно так, чтобы при выводе известным мне способом значения в строчках начального списка со списками
    for col in row:  # значения строчек были значениями столбцов.
        print(col, end='\t\t')
    print()
print()
print(liner * 8)
print('Задание №3')

dop = int(input('Введите количество: '))
n = []
cold = 0
for i in range(dop):
    sls = randint(0, 10)
    if sls in n:
        cold += 1
    else:
        n.append(sls)
print('Ваш уникальный массив: ', n)
print('В результате наполнения массива уникальными случайными значениями сгенерировалось', cold, 'повторных значений')
